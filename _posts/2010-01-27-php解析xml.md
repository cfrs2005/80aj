---
title: 100127 php 解析xml
layout: post
permalink: /855.html
categories:
  - Code
tags:
  - 3dmax
  - PHP
  - simple解析
  - xml
---
 前几天老大让我做了个东西  具体是这样的   原画 3D 组 画出来的人物数据 是无法直接导入到公司现在版本的游戏引擎 需要 做一些转换 超复杂 3d 原文件通过 软件 hacked 成xml->text的游戏引擎识别的数据格式 整体过程就用了简单的一个 simplexml解析 具体过程  加一些加工 hack 以后出来的 xml文件 包含了 2部分 \*.mesh.xml 面部结构文件 \*.skeleton.xml 节点动画文件 转出来的格式比较复杂  甚至是说我见过最恶心的格式&#8230; 好吧 不说其hack出来的内容有多恶心了 讲下工作具体思路吧 首先给的文件比较多 光一个人物就有10来个文件 实际上还是切割处理过的 不然。。文件会较大 解析难度更大。。甚至到吐血程度的困难 为了以后不用劳烦我帮他们转代码 我想还是做一套完成的工具给他们使用 这样以后就不用麻烦偶了 //返回目录集合 这里我直接做了 解析 和写入的工作 function listFiles ($dir) {     //打开目录     $handle = opendir($dir);     //阅读目录     while (false != ($file = readdir($handle))) {         //列出所有文件并去掉&#8217;.'和&#8217;..&#8217;         if ($file != &#8216;.&#8217; & $file != &#8216;..&#8217;) {             //所得到的文件名是否是一个目录             if (is\_dir(&#8220;$dir/$file&#8221;)) {                 //列出目录下的文件                 listFiles(&#8220;$dir/$file&#8221;);             } else {                 //如果是文件则打开该文件                 $fp = fopen(&#8220;$dir/$file&#8221;, &#8220;r&#8221;);                 //阅读文件内容                 $data = fread($fp, filesize(&#8220;$dir/$file&#8221;));                 if ($data)                     $file\_array\[] = &#8220;$dir/$file&#8221;;                     //输出结果                 while (list ($key, $value) = each($file\_array)) {                //正则取出文件后缀  符合的 则进行函数操作 解析写入文档                     //echo $value;                     $str = preg\_match\_all(&#8216;/<\*.mesh.xml/&#8217;, $value, $m);                     if ($str == 1) {                         $logtext = rewritexml($value);                         savetext($value, $logtext);                     }                     $str = preg\_match\_all(&#8216;/<\*.skeleton.xml/&#8217;, $value, $m);                     if ($str == 1) {                         $logtext = rewritexml\_skeleton($value);                         savetext($value, $logtext);                     }                 }             }         }     } } //内容写入 原谅我的懒惰 没有去判断 返回值实际上这只是个工具 内部使用 我就没有那么逻辑很谨慎了 function savetext ($name, $logtext) {     /*\*      \* @Author:ZhangQingYue      \* @Description: 方法介绍      \* @FirstCreatDate: 2010-1-22      \* @param : nuserid &#8211; 用户ID      \*/     $filename = $name . &#8220;.txt&#8221;;     $fp = fopen($filename, &#8220;a&#8221;);     flock($fp, LOCK\_EX);     fwrite($fp, $logtext);     flock($fp, LOCK\_UN);     fclose($fp); } //解析XML 返回解析以后的内容 function rewritexml ($filepatch) {     /*\*      \* @Author:ZhangQingYue      \* @Description: 方法介绍      \* @FirstCreatDate: 2010-1-22      \* @param : nuserid &#8211; 用户ID      \*/     $xml = simplexml\_load\_file($filepatch); //加载xml     $faces = $xml->submeshes->submesh->faces->face; //获取节点     $geometry = $xml->submeshes->submesh->geometry->vertexbuffer;     $boneassignments = $xml->submeshes->submesh->boneassignments->vertexboneassignment;     $str = array();     foreach ($geometry as $geometry\_single) {         //有for 循环 内存溢出bug 只能用 foreach 拼接   http://bugs.php.net/bug.php?id=41582         $i = 0;         foreach ($geometry\_single as $vertex) {             if ($vertex->position) {                 $str[$i\]\["p"\] = $vertex->position\['x'] . &#8220;,&#8221; . $vertex->position['y'] . &#8220;,&#8221; . $vertex->position['z'] . &#8220;;&#8221;;             }             if ($vertex->normal) {                 $str[$i\]\["n"\] = $vertex->normal\['x'] . &#8220;,&#8221; . $vertex->normal['y'] . &#8220;,&#8221; . $vertex->normal['z'] . &#8220;;&#8221;;             }             if ($vertex->colour\_diffuse) {                 $strx = $vertex->colour\_diffuse['value'] . &#8220;&#8221;;                 $strx = str\_replace(&#8216; &#8216;, &#8216;,&#8217;, $strx);                 $str[$i\]\["c"\] = $strx . &#8220;;&#8221;;             }             if ($vertex->texcoord) {                 $str\[$i\]\["t"\] = $vertex->texcoord\['u'] . &#8220;,&#8221; . $vertex->texcoord['v'] . &#8220;;&#8221;;             }             $i ++;         }     }     $logtext= &#8220;dingdianshumu:&#8221; . sizeof($str) . &#8220;\t\n&#8221;;     //sizeof($str)     for ($x = 1; $x < sizeof($str); $x ++) {         $logtext.=$str[$x\]\["p"\] . $str\[$x\]\["n"\] . $str\[$x\]\["c"\] . $str\[$x\]\["t"\] . &#8220;\t\n&#8221;;     }     $logtext.= &#8220;\t\n\t\nmianshumu:&#8221; . sizeof($faces) . &#8220;\t\n\t\n&#8221;;     foreach ($faces as $face) {        $logtext.= $face['v1'] . &#8220;,&#8221; . $face['v2'] . &#8220;,&#8221; . $face['v3'] . &#8220;\t\n&#8221;;     }      $logtext.=&#8221;\t\n\t\ngugeyingxiang\t\n\t\n&#8221;;     foreach ($boneassignments as $boneassignment) {         $logtext.= $boneassignment['vertexindex'] . &#8220;,&#8221; . $boneassignment['boneindex'] . &#8220;,&#8221; . $boneassignment['weight'] . &#8220;\t\n&#8221;;     }     return $logtext; } //最终实例调用-\_- so sigh~ 花费了 一个下午才做完的工作   $dir = &#8220;./&#8221;; listFiles($dir); 源码下载